# ğŸ”„ Complete Data Flow & Function Communication Guide

> **Deep dive into every function, its purpose, inputs, outputs, and interactions**

---

## ğŸ”¼ UPLOAD FLOW

### Complete Upload Sequence Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    USER ACTION                                  â”‚
â”‚              User selects PDF file                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  DocumentUpload.tsx                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ onDrop() / onChange()                                   â”‚   â”‚
â”‚  â”‚ INPUT: File (from user drag/drop or input)              â”‚   â”‚
â”‚  â”‚ PROCESS:                                                â”‚   â”‚
â”‚  â”‚  â€¢ Validate file type (PDF only)                        â”‚   â”‚
â”‚  â”‚  â€¢ Validate file size (<8MB)                            â”‚   â”‚
â”‚  â”‚  â€¢ Create FormData with file                            â”‚   â”‚
â”‚  â”‚ OUTPUT: Triggers startUpload()                          â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                  â”‚
â”‚  startUpload() [Uploadthing]                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ INPUT: File                                             â”‚   â”‚
â”‚  â”‚ PROCESS:                                                â”‚   â”‚
â”‚  â”‚  â€¢ Sends to Uploadthing service                         â”‚   â”‚
â”‚  â”‚  â€¢ Shows progress indicator                             â”‚   â”‚
â”‚  â”‚  â€¢ Stores file in cloud                                 â”‚   â”‚
â”‚  â”‚ OUTPUT: { fileUrl, fileName, key }                      â”‚   â”‚
â”‚  â”‚         Returns cloud-hosted URL                        â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚ fileUrl from Uploadthing
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  POST /api/uploadthing/route.ts                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ ON_UPLOAD_COMPLETE(data)                                â”‚   â”‚
â”‚  â”‚ INPUT: { file: { url, name, size } }                    â”‚   â”‚
â”‚  â”‚ PROCESS:                                                â”‚   â”‚
â”‚  â”‚  â€¢ Receives Uploadthing confirmation                    â”‚   â”‚
â”‚  â”‚  â€¢ Extracts file URL and name                           â”‚   â”‚
â”‚  â”‚  â€¢ Forwards to /api/upload-document                     â”‚   â”‚
â”‚  â”‚ OUTPUT: Calls handleDocumentUpload()                    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚ fileUrl, documentName, namespace
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  POST /api/upload-document/route.ts                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ POST Handler (Main Upload Endpoint)                     â”‚   â”‚
â”‚  â”‚ INPUT: { fileUrl, documentName, namespace }             â”‚   â”‚
â”‚  â”‚ PROCESS:                                                â”‚   â”‚
â”‚  â”‚  1. Validate inputs (check for null/empty)              â”‚   â”‚
â”‚  â”‚  2. Call: downloadFileFromUrl(fileUrl)                  â”‚   â”‚
â”‚  â”‚  3. Call: processPdfDocument(filepath, documentName)    â”‚   â”‚
â”‚  â”‚  4. Call: upsertVectors(vectors, namespace)             â”‚   â”‚
â”‚  â”‚  5. Call: registerDocument(metadata)                    â”‚   â”‚
â”‚  â”‚  6. Return stats and success message                    â”‚   â”‚
â”‚  â”‚ OUTPUT: {                                               â”‚   â”‚
â”‚  â”‚   success: true,                                        â”‚   â”‚
â”‚  â”‚   message: "Successfully processed X chunks",           â”‚   â”‚
â”‚  â”‚   stats: {                                              â”‚   â”‚
â”‚  â”‚     totalChunks,                                        â”‚   â”‚
â”‚  â”‚     totalVectors,                                       â”‚   â”‚
â”‚  â”‚     namespace,                                          â”‚   â”‚
â”‚  â”‚     documentName                                        â”‚   â”‚
â”‚  â”‚   }                                                     â”‚   â”‚
â”‚  â”‚ }                                                       â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                                 â”‚
        â–¼                                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ document-processor.ts            â”‚  â”‚ document-registry.ts   â”‚
â”‚                                  â”‚  â”‚                        â”‚
â”‚ processPdfDocument()             â”‚  â”‚ registerDocument()     â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚ â”‚ INPUT:                     â”‚   â”‚  â”‚ â”‚ INPUT: metadata  â”‚  â”‚
â”‚ â”‚ â€¢ filePath (from download) â”‚   â”‚  â”‚ â”‚ PROCESS:         â”‚  â”‚
â”‚ â”‚ â€¢ documentName             â”‚   â”‚  â”‚ â”‚  â€¢ Add to Map    â”‚  â”‚
â”‚ â”‚                            â”‚   â”‚  â”‚ â”‚  â€¢ Update sync   â”‚  â”‚
â”‚ â”‚ PROCESS:                   â”‚   â”‚  â”‚ â”‚ OUTPUT: void     â”‚  â”‚
â”‚ â”‚ 1. new PDFLoader(path)     â”‚   â”‚  â”‚ â”‚                  â”‚  â”‚
â”‚ â”‚ 2. load() â†’ PDF text+pages â”‚   â”‚  â”‚ â”‚ ASYNC: Yes       â”‚  â”‚
â”‚ â”‚ 3. RecursiveCharacterText  â”‚   â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚ â”‚    Splitter(config)        â”‚   â”‚  â”‚                       â”‚
â”‚ â”‚ 4. splitDocuments() â†’      â”‚   â”‚  â”‚ Storage Effect:       â”‚
â”‚ â”‚    chunks with metadata    â”‚   â”‚  â”‚ documentRegistry.set()â”‚
â”‚ â”‚ 5. Create chunk objects    â”‚   â”‚  â”‚ (in-memory cache)     â”‚
â”‚ â”‚    with unique IDs         â”‚   â”‚  â”‚                       â”‚
â”‚ â”‚ 6. Call getEmbeddings()    â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚ â”‚ 7. embedDocuments(texts)   â”‚   â”‚
â”‚ â”‚    â†’ vector array          â”‚   â”‚
â”‚ â”‚                            â”‚   â”‚
â”‚ â”‚ OUTPUT:                    â”‚   â”‚
â”‚ â”‚ [{                         â”‚   â”‚
â”‚ â”‚   id: "doc_chunk_0",       â”‚   â”‚
â”‚ â”‚   values: [...],           â”‚   â”‚
â”‚ â”‚   metadata: {              â”‚   â”‚
â”‚ â”‚     source: "filename",    â”‚   â”‚
â”‚ â”‚     page: 1,               â”‚   â”‚
â”‚ â”‚     text: "chunk text"     â”‚   â”‚
â”‚ â”‚   }                        â”‚   â”‚
â”‚ â”‚ }]                         â”‚   â”‚
â”‚ â”‚                            â”‚   â”‚
â”‚ â”‚ ASYNC: Yes                 â”‚   â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ embeddings.ts                                            â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚ â”‚ getEmbeddings()                                    â”‚   â”‚
â”‚ â”‚ INPUT: (none - singleton)                          â”‚   â”‚
â”‚ â”‚ PROCESS:                                           â”‚   â”‚
â”‚ â”‚  â€¢ Check if instance exists (singleton pattern)    â”‚   â”‚
â”‚ â”‚  â€¢ If not, create new GoogleGenerativeAIEmbeddings â”‚   â”‚
â”‚ â”‚  â€¢ Model: text-embedding-004                       â”‚   â”‚
â”‚ â”‚ OUTPUT: GoogleGenerativeAIEmbeddings instance      â”‚   â”‚
â”‚ â”‚                                                    â”‚   â”‚
â”‚ â”‚ embeddings.embedDocuments(texts)                   â”‚   â”‚
â”‚ â”‚ INPUT: string[] (text chunks)                      â”‚   â”‚
â”‚ â”‚ PROCESS:                                           â”‚   â”‚
â”‚ â”‚  â€¢ Sends to Google API                             â”‚   â”‚
â”‚ â”‚  â€¢ Generates 1536-dimensional vectors              â”‚   â”‚
â”‚ â”‚  â€¢ Returns array of vectors                        â”‚   â”‚
â”‚ â”‚ OUTPUT: number[][] (vectors)                       â”‚   â”‚
â”‚ â”‚ ASYNC: Yes                                         â”‚   â”‚
â”‚ â”‚                                                    â”‚   â”‚
â”‚ â”‚ CACHE: Yes (singleton instance reused)             â”‚   â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ pinecone.ts                                              â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚ â”‚ upsertVectors(vectors, namespace)                  â”‚   â”‚
â”‚ â”‚ INPUT:                                             â”‚   â”‚
â”‚ â”‚ â€¢ vectors: [{                                      â”‚   â”‚
â”‚ â”‚     id: string,                                    â”‚   â”‚
â”‚ â”‚     values: number[],                              â”‚   â”‚
â”‚ â”‚     metadata: {                                    â”‚   â”‚
â”‚ â”‚       source: string,                              â”‚   â”‚
â”‚ â”‚       page: number,                                â”‚   â”‚
â”‚ â”‚       text: string                                 â”‚   â”‚
â”‚ â”‚     }                                              â”‚   â”‚
â”‚ â”‚   }]                                               â”‚   â”‚
â”‚ â”‚ â€¢ namespace: string (e.g., "default")              â”‚   â”‚
â”‚ â”‚                                                    â”‚   â”‚
â”‚ â”‚ PROCESS:                                           â”‚   â”‚
â”‚ â”‚ 1. getPineconeClient() â†’ get/create client         â”‚   â”‚
â”‚ â”‚ 2. Connect to Pinecone index                       â”‚   â”‚
â”‚ â”‚ 3. Call index.upsert() with vectors                â”‚   â”‚
â”‚ â”‚ 4. Waits for confirmation                          â”‚   â”‚
â”‚ â”‚                                                    â”‚   â”‚
â”‚ â”‚ OUTPUT: void (success or throws error)             â”‚   â”‚
â”‚ â”‚ ASYNC: Yes                                         â”‚   â”‚
â”‚ â”‚                                                    â”‚   â”‚
â”‚ â”‚ STORAGE: Pinecone Cloud                            â”‚   â”‚
â”‚ â”‚ (vectors permanently stored)                       â”‚   â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âœ… UPLOAD COMPLETE                                       â”‚
â”‚                                                          â”‚
â”‚ Data Flow Summary:                                       â”‚
â”‚ File â†’ Uploadthing â†’ API â†’ Download â†’ Extract Text â†’   â”‚
â”‚ Chunk â†’ Embed â†’ Store in Pinecone â†’ Register in Cache  â”‚
â”‚                                                          â”‚
â”‚ Response sent to frontend with success confirmation     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ’¬ CHAT FLOW

### Complete Chat Sequence Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    USER ACTION                                  â”‚
â”‚          User types question and sends message                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ChatInput.tsx                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ handleSend() / onSubmit()                               â”‚   â”‚
â”‚  â”‚ INPUT: message string                                   â”‚   â”‚
â”‚  â”‚ PROCESS:                                                â”‚   â”‚
â”‚  â”‚  â€¢ Validate message not empty                           â”‚   â”‚
â”‚  â”‚  â€¢ Create request payload:                              â”‚   â”‚
â”‚  â”‚    {                                                    â”‚   â”‚
â”‚  â”‚      message,                                           â”‚   â”‚
â”‚  â”‚      namespace,                                         â”‚   â”‚
â”‚  â”‚      conversationHistory[],                             â”‚   â”‚
â”‚  â”‚      stream: false                                      â”‚   â”‚
â”‚  â”‚    }                                                    â”‚   â”‚
â”‚  â”‚  â€¢ Call fetch POST /api/chat                            â”‚   â”‚
â”‚  â”‚  â€¢ Show loading state                                   â”‚   â”‚
â”‚  â”‚ OUTPUT: Sends HTTP request to backend                   â”‚   â”‚
â”‚  â”‚ ASYNC: Yes                                              â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  POST /api/chat/route.ts                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ POST Handler (Main Chat Endpoint)                       â”‚   â”‚
â”‚  â”‚                                                         â”‚   â”‚
â”‚  â”‚ INPUT: {                                               â”‚   â”‚
â”‚  â”‚   message: string,                                     â”‚   â”‚
â”‚  â”‚   namespace?: string,                                  â”‚   â”‚
â”‚  â”‚   conversationHistory?: Array,                          â”‚   â”‚
â”‚  â”‚   stream?: boolean                                     â”‚   â”‚
â”‚  â”‚ }                                                      â”‚   â”‚
â”‚  â”‚                                                         â”‚   â”‚
â”‚  â”‚ PROCESS:                                                â”‚   â”‚
â”‚  â”‚ 1. Parse request body                                  â”‚   â”‚
â”‚  â”‚ 2. Validate inputs (message not empty)                 â”‚   â”‚
â”‚  â”‚ 3. Set default namespace = "default"                   â”‚   â”‚
â”‚  â”‚ 4. Call: ragPipeline(message, namespace,              â”‚   â”‚
â”‚  â”‚           conversationHistory)                          â”‚   â”‚
â”‚  â”‚ 5. Destructure: { response, retrievedDocs }            â”‚   â”‚
â”‚  â”‚ 6. Get doc count: getAllDocuments().length             â”‚   â”‚
â”‚  â”‚ 7. Return response object                              â”‚   â”‚
â”‚  â”‚                                                         â”‚   â”‚
â”‚  â”‚ OUTPUT: {                                               â”‚   â”‚
â”‚  â”‚   success: true,                                       â”‚   â”‚
â”‚  â”‚   response: "AI response text",                         â”‚   â”‚
â”‚  â”‚   retrievedDocuments: [{                                â”‚   â”‚
â”‚  â”‚     id: string,                                        â”‚   â”‚
â”‚  â”‚     score: number,                                     â”‚   â”‚
â”‚  â”‚     text: string,                                      â”‚   â”‚
â”‚  â”‚     source: string,                                    â”‚   â”‚
â”‚  â”‚     page: number                                       â”‚   â”‚
â”‚  â”‚   }],                                                  â”‚   â”‚
â”‚  â”‚   documentCount: number                                â”‚   â”‚
â”‚  â”‚ }                                                      â”‚   â”‚
â”‚  â”‚                                                         â”‚   â”‚
â”‚  â”‚ ERROR HANDLING:                                         â”‚   â”‚
â”‚  â”‚ â€¢ 400: Missing required fields                          â”‚   â”‚
â”‚  â”‚ â€¢ 500: RAG pipeline error                               â”‚   â”‚
â”‚  â”‚                                                         â”‚   â”‚
â”‚  â”‚ ASYNC: Yes                                              â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ chain.ts - RAG PIPELINE (Main orchestrator)                     â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚ â”‚ ragPipeline(query, namespace, history)                  â”‚   â”‚
â”‚ â”‚                                                         â”‚   â”‚
â”‚ â”‚ INPUT:                                                  â”‚   â”‚
â”‚ â”‚ â€¢ query: string (user question)                        â”‚   â”‚
â”‚ â”‚ â€¢ namespace: string (document namespace)                â”‚   â”‚
â”‚ â”‚ â€¢ conversationHistory?: Array (chat history)            â”‚   â”‚
â”‚ â”‚                                                         â”‚   â”‚
â”‚ â”‚ PROCESS:                                                â”‚   â”‚
â”‚ â”‚ 1. Call: retrieveRelevantDocuments(query, namespace)   â”‚   â”‚
â”‚ â”‚    â†’ returns top 5 relevant chunks with scores         â”‚   â”‚
â”‚ â”‚                                                         â”‚   â”‚
â”‚ â”‚ 2. Call: formatContext(retrievedDocs)                  â”‚   â”‚
â”‚ â”‚    â†’ formats chunks into string context                â”‚   â”‚
â”‚ â”‚                                                         â”‚   â”‚
â”‚ â”‚ 3. Call: generateResponse(query, context,              â”‚   â”‚
â”‚ â”‚           retrievedDocs, history)                       â”‚   â”‚
â”‚ â”‚    â†’ calls Gemini LLM                                  â”‚   â”‚
â”‚ â”‚                                                         â”‚   â”‚
â”‚ â”‚ OUTPUT: {                                               â”‚   â”‚
â”‚ â”‚   response: "LLM generated answer",                     â”‚   â”‚
â”‚ â”‚   retrievedDocs: [chunk metadata + scores]             â”‚   â”‚
â”‚ â”‚ }                                                      â”‚   â”‚
â”‚ â”‚                                                         â”‚   â”‚
â”‚ â”‚ ASYNC: Yes                                              â”‚   â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚          â”‚          â”‚
              â–¼          â–¼          â–¼
    Step 1    Step 2    Step 3
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STEP 1: Retrieve Relevant Documents                      â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚ â”‚ retrieveRelevantDocuments(query, namespace)        â”‚   â”‚
â”‚ â”‚                                                    â”‚   â”‚
â”‚ â”‚ INPUT:                                             â”‚   â”‚
â”‚ â”‚ â€¢ query: string (user question)                   â”‚   â”‚
â”‚ â”‚ â€¢ namespace: string                                â”‚   â”‚
â”‚ â”‚                                                    â”‚   â”‚
â”‚ â”‚ PROCESS:                                           â”‚   â”‚
â”‚ â”‚ 1. Call: getEmbeddings()                           â”‚   â”‚
â”‚ â”‚ 2. Call: embeddings.embedQuery(query)              â”‚   â”‚
â”‚ â”‚    â†’ converts query to 1536D vector                â”‚   â”‚
â”‚ â”‚ 3. Call: queryVectors(queryVector, topK=5)         â”‚   â”‚
â”‚ â”‚    â†’ searches Pinecone for similar vectors         â”‚   â”‚
â”‚ â”‚ 4. Filter results if confidence > 0.7              â”‚   â”‚
â”‚ â”‚ 5. Format with metadata (source, page, text)       â”‚   â”‚
â”‚ â”‚                                                    â”‚   â”‚
â”‚ â”‚ OUTPUT: [{                                         â”‚   â”‚
â”‚ â”‚   id: "doc_chunk_0",                               â”‚   â”‚
â”‚ â”‚   score: 0.87,                                     â”‚   â”‚
â”‚ â”‚   text: "chunk content",                           â”‚   â”‚
â”‚ â”‚   metadata: {                                      â”‚   â”‚
â”‚ â”‚     source: "filename",                            â”‚   â”‚
â”‚ â”‚     page: 1                                        â”‚   â”‚
â”‚ â”‚   }                                                â”‚   â”‚
â”‚ â”‚ }]                                                 â”‚   â”‚
â”‚ â”‚                                                    â”‚   â”‚
â”‚ â”‚ ASYNC: Yes                                         â”‚   â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                          â”‚
â”‚  Sub-functions:                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ embeddings.embedQuery(query)                       â”‚  â”‚
â”‚  â”‚ INPUT: string (user question)                      â”‚  â”‚
â”‚  â”‚ PROCESS: Sends to Google Gemini Embeddings API    â”‚  â”‚
â”‚  â”‚ OUTPUT: number[] (1536-dimensional vector)        â”‚  â”‚
â”‚  â”‚ ASYNC: Yes                                        â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ queryVectors(vector, topK, namespace)              â”‚  â”‚
â”‚  â”‚ INPUT:                                             â”‚  â”‚
â”‚  â”‚ â€¢ vector: number[] (query embedding)               â”‚  â”‚
â”‚  â”‚ â€¢ topK: number = 5                                 â”‚  â”‚
â”‚  â”‚ â€¢ namespace: string                                â”‚  â”‚
â”‚  â”‚                                                    â”‚  â”‚
â”‚  â”‚ PROCESS:                                           â”‚  â”‚
â”‚  â”‚ 1. Get Pinecone client                             â”‚  â”‚
â”‚  â”‚ 2. Call index.query({                              â”‚  â”‚
â”‚  â”‚      vector,                                       â”‚  â”‚
â”‚  â”‚      topK,                                         â”‚  â”‚
â”‚  â”‚      namespace,                                    â”‚  â”‚
â”‚  â”‚      includeMetadata: true                         â”‚  â”‚
â”‚  â”‚    })                                              â”‚  â”‚
â”‚  â”‚ 3. Pinecone returns matches with scores            â”‚  â”‚
â”‚  â”‚                                                    â”‚  â”‚
â”‚  â”‚ OUTPUT: {                                          â”‚  â”‚
â”‚  â”‚   matches: [{                                      â”‚  â”‚
â”‚  â”‚     id: string,                                    â”‚  â”‚
â”‚  â”‚     score: number,                                 â”‚  â”‚
â”‚  â”‚     metadata: { source, page, text }               â”‚  â”‚
â”‚  â”‚   }]                                               â”‚  â”‚
â”‚  â”‚ }                                                  â”‚  â”‚
â”‚  â”‚                                                    â”‚  â”‚
â”‚  â”‚ ASYNC: Yes                                         â”‚  â”‚
â”‚  â”‚ NETWORK: Yes (Pinecone serverless)                 â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STEP 2: Format Context                                   â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚ â”‚ formatContext(retrievedDocuments)                  â”‚   â”‚
â”‚ â”‚                                                    â”‚   â”‚
â”‚ â”‚ INPUT: [{                                          â”‚   â”‚
â”‚ â”‚   score: 0.87,                                     â”‚   â”‚
â”‚ â”‚   text: "chunk text",                              â”‚   â”‚
â”‚ â”‚   metadata: { source, page }                       â”‚   â”‚
â”‚ â”‚ }]                                                 â”‚   â”‚
â”‚ â”‚                                                    â”‚   â”‚
â”‚ â”‚ PROCESS:                                           â”‚   â”‚
â”‚ â”‚ 1. Iterate through each retrieved document        â”‚   â”‚
â”‚ â”‚ 2. Format as: "[Source: filename, Page: 1]        â”‚   â”‚
â”‚ â”‚    chunk text"                                    â”‚   â”‚
â”‚ â”‚ 3. Join with newlines                             â”‚   â”‚
â”‚ â”‚ 4. Return formatted string                         â”‚   â”‚
â”‚ â”‚                                                    â”‚   â”‚
â”‚ â”‚ OUTPUT: string (formatted context for LLM)        â”‚   â”‚
â”‚ â”‚ EXAMPLE:                                           â”‚   â”‚
â”‚ â”‚ "[Source: report.pdf, Page: 1]                    â”‚   â”‚
â”‚ â”‚  Revenue in Q3 was $5M...                         â”‚   â”‚
â”‚ â”‚  [Source: report.pdf, Page: 2]                    â”‚   â”‚
â”‚ â”‚  Operating costs decreased..."                    â”‚   â”‚
â”‚ â”‚                                                    â”‚   â”‚
â”‚ â”‚ SYNC: Yes (no async operations)                    â”‚   â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STEP 3: Generate Response                                â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚ â”‚ generateResponse(query, context, docs, history)    â”‚   â”‚
â”‚ â”‚                                                    â”‚   â”‚
â”‚ â”‚ INPUT:                                             â”‚   â”‚
â”‚ â”‚ â€¢ query: string (user question)                   â”‚   â”‚
â”‚ â”‚ â€¢ context: string (formatted retrieved docs)       â”‚   â”‚
â”‚ â”‚ â€¢ docs: array (raw retrieved docs)                â”‚   â”‚
â”‚ â”‚ â€¢ history: array (conversation history)            â”‚   â”‚
â”‚ â”‚                                                    â”‚   â”‚
â”‚ â”‚ PROCESS:                                           â”‚   â”‚
â”‚ â”‚ 1. Call: getGeminiClient()                         â”‚   â”‚
â”‚ â”‚    â†’ gets/creates Google Generative AI client      â”‚   â”‚
â”‚ â”‚                                                    â”‚   â”‚
â”‚ â”‚ 2. Build messages array:                           â”‚   â”‚
â”‚ â”‚    [{                                              â”‚   â”‚
â”‚ â”‚      role: "user",                                 â”‚   â”‚
â”‚ â”‚      content: query + context                      â”‚   â”‚
â”‚ â”‚    }]                                              â”‚   â”‚
â”‚ â”‚                                                    â”‚   â”‚
â”‚ â”‚ 3. Call: isDocumentInventoryQuery(query)           â”‚   â”‚
â”‚ â”‚    â†’ checks if asking "what documents?"            â”‚   â”‚
â”‚ â”‚                                                    â”‚   â”‚
â”‚ â”‚ 4. If inventory query:                             â”‚   â”‚
â”‚ â”‚    â€¢ Call: getAllDocuments()                       â”‚   â”‚
â”‚ â”‚    â€¢ Call: getDocumentStats()                      â”‚   â”‚
â”‚ â”‚    â€¢ Enrich context with catalog                   â”‚   â”‚
â”‚ â”‚                                                    â”‚   â”‚
â”‚ â”‚ 5. Build LLM request:                              â”‚   â”‚
â”‚ â”‚    client.generateContent({                        â”‚   â”‚
â”‚ â”‚      systemInstruction: SYSTEM_PROMPT,             â”‚   â”‚
â”‚ â”‚      contents: messagesArray,                      â”‚   â”‚
â”‚ â”‚      generationConfig: {                           â”‚   â”‚
â”‚ â”‚        temperature: 0.7,                           â”‚   â”‚
â”‚ â”‚        maxOutputTokens: 1024                       â”‚   â”‚
â”‚ â”‚      }                                             â”‚   â”‚
â”‚ â”‚    })                                              â”‚   â”‚
â”‚ â”‚                                                    â”‚   â”‚
â”‚ â”‚ 6. Parse response text                             â”‚   â”‚
â”‚ â”‚                                                    â”‚   â”‚
â”‚ â”‚ OUTPUT: string (AI-generated response)             â”‚   â”‚
â”‚ â”‚ ASYNC: Yes                                         â”‚   â”‚
â”‚ â”‚ NETWORK: Yes (Google Gemini API)                   â”‚   â”‚
â”‚ â”‚                                                    â”‚   â”‚
â”‚ â”‚ CONFIGURATION:                                     â”‚   â”‚
â”‚ â”‚ â€¢ Model: "gemini-1.5-pro"                         â”‚   â”‚
â”‚ â”‚ â€¢ Temperature: 0.7 (balanced creativity)           â”‚   â”‚
â”‚ â”‚ â€¢ Max Tokens: 1024 (response length limit)         â”‚   â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                          â”‚
â”‚  Sub-functions:                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ getGeminiClient()                                  â”‚  â”‚
â”‚  â”‚ INPUT: (none - singleton)                          â”‚  â”‚
â”‚  â”‚ PROCESS:                                           â”‚  â”‚
â”‚  â”‚ â€¢ Check if client instance exists                  â”‚  â”‚
â”‚  â”‚ â€¢ If not, create new GoogleGenerativeAI()          â”‚  â”‚
â”‚  â”‚ OUTPUT: GoogleGenerativeAI instance                â”‚  â”‚
â”‚  â”‚ CACHE: Yes (singleton pattern)                     â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ isDocumentInventoryQuery(query)                    â”‚  â”‚
â”‚  â”‚ INPUT: string (user message)                       â”‚  â”‚
â”‚  â”‚ PROCESS:                                           â”‚  â”‚
â”‚  â”‚ â€¢ Check if lowercase query includes:               â”‚  â”‚
â”‚  â”‚   "document", "documents", "list", "what do",      â”‚  â”‚
â”‚  â”‚   "what documents", "show documents", etc.         â”‚  â”‚
â”‚  â”‚ OUTPUT: boolean                                    â”‚  â”‚
â”‚  â”‚ SYNC: Yes (string matching)                        â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ getAllDocuments()                                  â”‚  â”‚
â”‚  â”‚ INPUT: (none)                                      â”‚  â”‚
â”‚  â”‚ PROCESS:                                           â”‚  â”‚
â”‚  â”‚ â€¢ Return documentRegistry.values()                 â”‚  â”‚
â”‚  â”‚ â€¢ Converts Map to array of DocumentMetadata        â”‚  â”‚
â”‚  â”‚ OUTPUT: DocumentMetadata[]                         â”‚  â”‚
â”‚  â”‚ SYNC: Yes (in-memory operation)                    â”‚  â”‚
â”‚  â”‚ SPEED: O(n) where n = document count               â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ getDocumentStats()                                 â”‚  â”‚
â”‚  â”‚ INPUT: (none)                                      â”‚  â”‚
â”‚  â”‚ PROCESS:                                           â”‚  â”‚
â”‚  â”‚ â€¢ Calculate total chunks from all documents        â”‚  â”‚
â”‚  â”‚ â€¢ Calculate total pages if available               â”‚  â”‚
â”‚  â”‚ â€¢ Return stats object                              â”‚  â”‚
â”‚  â”‚ OUTPUT: {                                          â”‚  â”‚
â”‚  â”‚   totalDocuments: number,                          â”‚  â”‚
â”‚  â”‚   totalChunks: number,                             â”‚  â”‚
â”‚  â”‚   totalPages: number                               â”‚  â”‚
â”‚  â”‚ }                                                  â”‚  â”‚
â”‚  â”‚ SYNC: Yes (in-memory calculation)                  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Response Sent Back to Frontend

```
        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Response travels back through                                  â”‚
â”‚  API route â†’ HTTP response â†’ Frontend                           â”‚
â”‚                                                                 â”‚
â”‚  JSON Response: {                                               â”‚
â”‚    success: true,                                               â”‚
â”‚    response: "AI answer text",                                  â”‚
â”‚    retrievedDocuments: [                                        â”‚
â”‚      {                                                          â”‚
â”‚        id: "doc_chunk_0",                                       â”‚
â”‚        score: 0.87,                                             â”‚
â”‚        text: "chunk content",                                   â”‚
â”‚        source: "filename.pdf",                                  â”‚
â”‚        page: 1                                                  â”‚
â”‚      }                                                          â”‚
â”‚    ],                                                           â”‚
â”‚    documentCount: 23                                            â”‚
â”‚  }                                                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  MessageList.tsx - Display Response                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ renderMessages()                                        â”‚   â”‚
â”‚  â”‚ INPUT: Response data from API                           â”‚   â”‚
â”‚  â”‚ PROCESS:                                                â”‚   â”‚
â”‚  â”‚  â€¢ Add AI response to messages list                     â”‚   â”‚
â”‚  â”‚  â€¢ Display retrieved documents as citations             â”‚   â”‚
â”‚  â”‚  â€¢ Show relevance scores                                â”‚   â”‚
â”‚  â”‚  â€¢ Auto-scroll to latest message                        â”‚   â”‚
â”‚  â”‚ OUTPUT: Rendered message components                     â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

        â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âœ… CHAT COMPLETE - User sees response with sources             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“š FUNCTION REFERENCE

### Organized by File

---

## **1. src/components/upload/DocumentUpload.tsx**

### Function: `onDrop(acceptedFiles)`
- **Purpose**: Handle file drop event
- **Input**: File[] (from drag & drop)
- **Process**: Validate file type and size, trigger upload
- **Output**: Calls startUpload()
- **Async**: Yes
- **Error Handling**: Shows toast if file invalid

### Function: `onChange(event)`
- **Purpose**: Handle file input change
- **Input**: React ChangeEvent
- **Process**: Extract file from input, validate, trigger upload
- **Output**: Calls startUpload()
- **Async**: Yes

### Function: `startUpload(files)`
- **Purpose**: Upload files to Uploadthing
- **Input**: File[]
- **Process**: Sends to Uploadthing service (external)
- **Output**: FileRouter callback response with URL
- **Async**: Yes (external service)

### Function: `onClientUploadComplete(res)`
- **Purpose**: Handle successful upload
- **Input**: Uploadthing response with fileUrl and name
- **Process**: Send fileUrl to backend API
- **Output**: Calls POST /api/upload-document
- **Async**: Yes

### Function: `onUploadError(error)`
- **Purpose**: Handle upload error
- **Input**: Error object
- **Process**: Log error, show error toast to user
- **Output**: Toast notification
- **Async**: No

---

## **2. src/app/api/uploadthing/core.ts**

### Function: `f()` (main export)
- **Purpose**: Define upload route configuration
- **Input**: (none - configuration object)
- **Process**: Configure PDF uploader restrictions
- **Output**: FileRouter with upload handlers
- **Restrictions**:
  - maxFileSize: "8MB"
  - allowedFileTypes: ["application/pdf"]

### Function: `onUploadComplete(data)`
- **Purpose**: Handle successful file storage
- **Input**: UploadedFile data with URL
- **Process**: Extract file info, call handleDocumentUpload
- **Output**: Calls next API route
- **Async**: Yes

---

## **3. src/app/api/upload-document/route.ts**

### Function: `POST(request)`
- **Purpose**: Main upload endpoint
- **Input**: HTTP POST request with JSON body:
  ```typescript
  {
    fileUrl: string,
    documentName: string,
    namespace?: string
  }
  ```
- **Process**:
  1. Parse request JSON
  2. Validate inputs (not null/empty)
  3. Set default namespace
  4. Download file from URL
  5. Process PDF document
  6. Generate embeddings
  7. Upsert vectors to Pinecone
  8. Register document in cache
- **Output**: JSON response:
  ```typescript
  {
    success: true,
    message: string,
    stats: {
      totalChunks: number,
      totalVectors: number,
      namespace: string,
      documentName: string
    }
  }
  ```
- **Async**: Yes
- **Error Handling**: Returns 400/500 with error message

### Function: `downloadFileFromUrl(fileUrl)`
- **Purpose**: Download PDF from Uploadthing
- **Input**: fileUrl (string)
- **Process**: Fetch file, save to temp location
- **Output**: File path (string)
- **Async**: Yes
- **Error Handling**: Throws error if download fails

---

## **4. src/lib/rag/document-processor.ts**

### Function: `processPdfDocument(filePath, documentName)`
- **Purpose**: Extract and chunk PDF
- **Input**:
  - filePath: string (local file path)
  - documentName: string (for metadata)
- **Process**:
  1. Create PDFLoader instance
  2. Load PDF â†’ extract text + pages
  3. Create RecursiveCharacterTextSplitter
  4. Split document into chunks (1000 chars, 200 overlap)
  5. Get embeddings instance
  6. Generate embeddings for all chunks
  7. Create vector objects with metadata
- **Output**: Vector array:
  ```typescript
  [{
    id: "documentName_chunk_0",
    values: number[],
    metadata: {
      source: "documentName",
      page: 1,
      text: "chunk content"
    }
  }]
  ```
- **Async**: Yes
- **Error Handling**: Throws error if PDF invalid or extraction fails

### Function: `ChunkConfig` (constant)
- **Purpose**: Configuration for text splitting
- **Value**:
  ```typescript
  {
    chunkSize: 1000,
    chunkOverlap: 200
  }
  ```

---

## **5. src/lib/rag/embeddings.ts**

### Function: `getEmbeddings()`
- **Purpose**: Get or create embeddings instance (singleton)
- **Input**: (none)
- **Process**:
  - Check if embeddings instance exists
  - If not, create GoogleGenerativeAIEmbeddings
  - Model: "text-embedding-004"
- **Output**: GoogleGenerativeAIEmbeddings instance
- **Async**: No (instantiation only)
- **Caching**: Yes (singleton)

### Instance Method: `embeddings.embedDocuments(texts)`
- **Purpose**: Generate embeddings for multiple texts
- **Input**: string[] (text chunks)
- **Process**: Send to Google Gemini API
- **Output**: number[][] (vectors, each 1536 dimensions)
- **Async**: Yes
- **Batch**: Multiple texts at once

### Instance Method: `embeddings.embedQuery(query)`
- **Purpose**: Generate embedding for single query
- **Input**: string (user question)
- **Process**: Send to Google Gemini API
- **Output**: number[] (1536 dimensions)
- **Async**: Yes

---

## **6. src/lib/rag/pinecone.ts**

### Function: `getPineconeClient()`
- **Purpose**: Get or create Pinecone client (singleton)
- **Input**: (none)
- **Process**:
  - Check if client exists
  - If not, create new Pinecone Serverless client
  - Uses PINECONE_API_KEY from env
- **Output**: Pinecone client instance
- **Async**: No
- **Caching**: Yes (singleton)

### Function: `queryVectors(vector, topK, namespace)`
- **Purpose**: Search Pinecone for similar vectors
- **Input**:
  - vector: number[] (query embedding)
  - topK: number = 5
  - namespace: string = "default"
- **Process**:
  1. Get Pinecone client
  2. Get index reference
  3. Call index.query() with vector
  4. Filter by namespace
  5. Include metadata in results
- **Output**:
  ```typescript
  {
    matches: [{
      id: string,
      score: number (0-1),
      metadata: {
        source: string,
        page: number,
        text: string
      }
    }]
  }
  ```
- **Async**: Yes
- **Network**: Yes (Pinecone serverless)

### Function: `upsertVectors(vectors, namespace)`
- **Purpose**: Store vectors in Pinecone
- **Input**:
  - vectors: vector object array
  - namespace: string = "default"
- **Process**:
  1. Get Pinecone client
  2. Get index reference
  3. Call index.upsert() with vectors
  4. Wait for confirmation
- **Output**: void (success) or throws error
- **Async**: Yes
- **Side Effect**: Vectors permanently stored in Pinecone

### Function: `discoverDocumentsFromPinecone(namespace)`
- **Purpose**: Auto-discover documents from vectors
- **Input**: namespace?: string
- **Process**:
  1. Query Pinecone for all vectors
  2. Extract unique sources from metadata
  3. Group chunks by source
  4. Build document metadata objects
- **Output**: DocumentMetadata[]
  ```typescript
  [{
    documentId: string,
    fileName: string,
    uploadedAt: Date,
    namespace: string,
    totalChunks: number,
    status: "complete"
  }]
  ```
- **Async**: Yes
- **Purpose**: Recovery after restart

---

## **7. src/lib/rag/document-registry.ts**

### Variable: `documentRegistry`
- **Type**: Map<string, DocumentMetadata>
- **Purpose**: In-memory cache of documents
- **Scope**: Module-level
- **Persistence**: Lost on app restart (synced from Pinecone)

### Function: `initializeRegistry()`
- **Purpose**: Initialize registry on app startup
- **Input**: (none)
- **Process**:
  1. Log initialization start
  2. Call syncRegistryWithPinecone()
  3. Log completion
- **Output**: void
- **Async**: Yes
- **Timing**: Called once on app startup

### Function: `registerDocument(metadata)`
- **Purpose**: Add document to registry
- **Input**:
  ```typescript
  {
    documentId: string,
    fileName: string,
    uploadedAt: Date,
    namespace: string,
    totalChunks: number,
    status: string
  }
  ```
- **Process**:
  1. Validate metadata
  2. Add to documentRegistry Map
  3. Update lastSyncTime
- **Output**: void
- **Async**: No
- **Side Effect**: Updates in-memory cache

### Function: `getAllDocuments()`
- **Purpose**: Get all documents from cache
- **Input**: (none)
- **Process**: Return documentRegistry.values() as array
- **Output**: DocumentMetadata[]
- **Async**: No
- **Speed**: O(n) where n = document count

### Function: `syncRegistryWithPinecone(namespace)`
- **Purpose**: Sync cache with Pinecone
- **Input**: namespace?: string
- **Process**:
  1. Check if recent sync exists
  2. Skip if synced recently and cache not empty
  3. Call discoverDocumentsFromPinecone()
  4. Update documentRegistry with results
  5. Update lastSyncTime
- **Output**: void
- **Async**: Yes
- **Frequency**: Every 5 minutes (SYNC_INTERVAL)
- **Manual**: Can be called via API

### Function: `getDocumentStats()`
- **Purpose**: Get statistics about documents
- **Input**: (none)
- **Process**:
  1. Iterate through all documents
  2. Sum totalChunks from each
  3. Sum totalPages if available
- **Output**:
  ```typescript
  {
    totalDocuments: number,
    totalChunks: number,
    totalPages: number
  }
  ```
- **Async**: No

### Function: `clearRegistry()`
- **Purpose**: Clear all documents (utility)
- **Input**: (none)
- **Process**: Clear documentRegistry Map
- **Output**: void
- **Async**: No
- **Warning**: Dangerous - only for testing

### Constant: `SYNC_INTERVAL`
- **Value**: 5 * 60 * 1000 (5 minutes)
- **Purpose**: Auto-sync frequency
- **Configurable**: Yes

---

## **8. src/lib/rag/chain.ts**

### Function: `ragPipeline(query, namespace, history)`
- **Purpose**: Main RAG orchestrator
- **Input**:
  - query: string (user question)
  - namespace: string (default: "default")
  - history?: ConversationMessage[]
- **Process**:
  1. Call retrieveRelevantDocuments()
  2. Call formatContext()
  3. Call generateResponse()
  4. Return combined response
- **Output**:
  ```typescript
  {
    response: string,
    retrievedDocs: DocumentMatch[]
  }
  ```
- **Async**: Yes
- **Main Function**: Coordinates all RAG steps

### Function: `retrieveRelevantDocuments(query, namespace)`
- **Purpose**: Search for similar documents
- **Input**:
  - query: string
  - namespace: string
- **Process**:
  1. Get embeddings instance
  2. embedQuery() â†’ convert query to vector
  3. queryVectors() â†’ search Pinecone
  4. Format results with scores
  5. Filter by confidence threshold (0.7)
- **Output**: DocumentMatch[]
  ```typescript
  [{
    id: string,
    score: number,
    text: string,
    source: string,
    page: number
  }]
  ```
- **Async**: Yes
- **topK**: 5 (configurable)

### Function: `formatContext(documents)`
- **Purpose**: Format retrieved docs for LLM
- **Input**: DocumentMatch[] (retrieved documents)
- **Process**:
  1. For each document:
     - Extract source and page
     - Extract text
     - Format as "[Source: X, Page: Y] text"
  2. Join all with newlines
- **Output**: string (formatted context)
- **Async**: No
- **Example Output**:
  ```
  [Source: report.pdf, Page: 1]
  Revenue increased by 20%...
  [Source: report.pdf, Page: 2]
  Operating expenses decreased...
  ```

### Function: `generateResponse(query, context, docs, history)`
- **Purpose**: Generate AI response
- **Input**:
  - query: string (user question)
  - context: string (formatted retrieved docs)
  - docs: DocumentMatch[] (raw documents)
  - history?: ConversationMessage[]
- **Process**:
  1. Get Gemini client
  2. Check if inventory query
  3. If yes: enrich context with document catalog
  4. Build messages array with context
  5. Call client.generateContent()
  6. Parse and return response
- **Output**: string (AI response)
- **Async**: Yes
- **Config**:
  - Model: "gemini-1.5-pro"
  - Temperature: 0.7
  - maxOutputTokens: 1024

### Function: `getGeminiClient()`
- **Purpose**: Get or create Gemini client (singleton)
- **Input**: (none)
- **Process**: Create GoogleGenerativeAI instance if not exists
- **Output**: GoogleGenerativeAI instance
- **Async**: No
- **Caching**: Yes

### Function: `isDocumentInventoryQuery(query)`
- **Purpose**: Detect "what documents" questions
- **Input**: query string
- **Process**:
  - Convert to lowercase
  - Check for keywords: "document", "documents", "list", "what do", "catalog", etc.
- **Output**: boolean
- **Async**: No

### Constant: `SYSTEM_PROMPT`
- **Purpose**: System instruction for Gemini
- **Content**: Instructs AI on document analysis behavior
- **Key Points**: 
  - Be helpful and accurate
  - Reference sources
  - Admit when uncertain

---

## **9. src/app/page.tsx (Main Chat Interface)**

### Component: `ChatPage()`
- **Purpose**: Main chat application
- **State Management**:
  - messages: Message[] (chat history)
  - isLoading: boolean (API loading state)
  - namespace: string (current namespace)
- **Render**:
  - DocumentUpload component
  - MessageList component
  - ChatInput component

---

## **10. src/components/chat/ChatInput.tsx**

### Function: `onSubmit(e)`
- **Purpose**: Handle message submission
- **Input**: React FormEvent
- **Process**:
  1. Prevent default
  2. Validate message not empty
  3. Create request payload
  4. Call fetch POST /api/chat
  5. Update messages on response
  6. Handle errors
- **Output**: HTTP request to backend
- **Async**: Yes

### Function: `handleKeyDown(e)`
- **Purpose**: Handle keyboard shortcuts
- **Input**: React KeyboardEvent
- **Process**: Trigger submit on Ctrl+Enter
- **Output**: Calls onSubmit()
- **Async**: No

---

## **11. src/components/chat/MessageList.tsx**

### Function: `renderMessages()`
- **Purpose**: Display chat messages
- **Input**: messages array from state
- **Process**:
  1. Map through messages
  2. Render user and AI messages differently
  3. Show retrieved documents for AI responses
  4. Auto-scroll to bottom
- **Output**: Rendered JSX components
- **Async**: No

### Function: `useEffect(() => scroll())`
- **Purpose**: Auto-scroll on new messages
- **Input**: messages array (dependency)
- **Process**: Scroll to bottom when messages change
- **Output**: DOM manipulation
- **Async**: No

---

## ğŸ”— DATA STRUCTURES

### DocumentMetadata
```typescript
{
  documentId: string,        // Unique ID
  fileName: string,          // Original filename
  uploadedAt: Date,          // Upload timestamp
  namespace: string,         // Namespace for organization
  totalChunks: number,       // Number of chunks
  status: "complete" | "processing" | "failed"
}
```

### Vector (Pinecone)
```typescript
{
  id: string,                // "documentName_chunk_0"
  values: number[],          // 1536-dimensional vector
  metadata: {
    source: string,          // Document filename
    page: number,            // PDF page number
    text: string             // Chunk content
  }
}
```

### DocumentMatch (Retrieved)
```typescript
{
  id: string,
  score: number,             // 0-1 relevance score
  text: string,              // Chunk content
  source: string,            // Document name
  page: number               // PDF page
}
```

### Message
```typescript
{
  role: "user" | "assistant",
  content: string,
  retrievedDocuments?: DocumentMatch[]
}
```

---

## âš ï¸ ERROR HANDLING

### Upload Errors
- **File validation**: Show toast "Invalid file type or size"
- **Download failure**: Return 500 "Failed to download file"
- **PDF extraction**: Return 500 "Failed to extract PDF"
- **Embedding generation**: Return 500 "Failed to generate embeddings"
- **Pinecone upsert**: Return 500 "Failed to store vectors"

### Chat Errors
- **Missing query**: Return 400 "Message required"
- **Retrieval failure**: Return 500 "Failed to retrieve documents"
- **Gemini API error**: Return 500 "Failed to generate response"
- **Network error**: Show toast "Connection failed"

### Logging
- Console.log for all major operations
- Error stacks for debugging
- Timestamps for tracking

---

## ğŸ”„ COMPLETE DATA FLOW SUMMARY

```
USER UPLOADS PDF
  â†“
DocumentUpload component
  â†“
Uploadthing stores file (cloud)
  â†“
/api/uploadthing/core.ts receives confirmation
  â†“
/api/upload-document/route.ts processes
  â†“
  â”œâ”€ downloadFileFromUrl() â†’ file
  â”œâ”€ processPdfDocument() â†’ chunks + embeddings
  â”œâ”€ embeddings.embedDocuments() â†’ vectors
  â”œâ”€ upsertVectors() â†’ Pinecone stores
  â””â”€ registerDocument() â†’ in-memory cache
  â†“
âœ… Response: stats and confirmation

---

USER ASKS QUESTION
  â†“
ChatInput component
  â†“
/api/chat/route.ts receives query
  â†“
ragPipeline() orchestrates:
  â”œâ”€ embeddings.embedQuery() â†’ query vector
  â”œâ”€ queryVectors() â†’ Pinecone searches
  â”œâ”€ formatContext() â†’ prepare context
  â”œâ”€ isDocumentInventoryQuery() â†’ check type
  â”œâ”€ generateResponse() â†’ Gemini API
  â””â”€ return response + sources
  â†“
MessageList component displays
  â”œâ”€ AI response
  â”œâ”€ Retrieved documents
  â””â”€ Relevance scores
  â†“
âœ… User sees answer with sources
```

